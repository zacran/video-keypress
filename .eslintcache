[{"/Users/zcranfill/Test/video-keypress/src/index.js":"1","/Users/zcranfill/Test/video-keypress/src/App.js":"2","/Users/zcranfill/Test/video-keypress/src/components/Chart.js":"3","/Users/zcranfill/Test/video-keypress/src/hooks/keybindMap.js":"4"},{"size":145,"mtime":1611462971353,"results":"5","hashOfConfig":"6"},{"size":25659,"mtime":1611463202450,"results":"7","hashOfConfig":"6"},{"size":12011,"mtime":1611325371532,"results":"8","hashOfConfig":"6"},{"size":458,"mtime":1610830502322,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"5od0xb",{"filePath":"12","messages":"13","errorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"14","messages":"15","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16","usedDeprecatedRules":"17"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"17"},"/Users/zcranfill/Test/video-keypress/src/index.js",[],"/Users/zcranfill/Test/video-keypress/src/App.js",["20","21","22","23","24","25","26","27","28","29","30","31"],"/Users/zcranfill/Test/video-keypress/src/components/Chart.js",["32"],"import React, { useState, useEffect } from \"react\";\nimport { Chart as GoogleChart } from \"react-google-charts\";\nimport Typography from '@material-ui/core/Typography';\nimport Grid from '@material-ui/core/Grid';\nimport Paper from '@material-ui/core/Paper';\nimport KeybindMap from \"../hooks/keybindMap\"\nimport { makeStyles } from '@material-ui/core/styles';\nimport \"../App.css\";\n\nconst COMPUTE_DERIVED_FIELDS_INTERVAL = 1000;\nconst MIN_EVENT_DURATION = 0.01; // In seconds\n\nfunction convertToMilliseconds(value) {\n    return value * 1000\n}\n\nfunction formatTime(value) {\n    var fixedValue = value.toFixed(2);\n    if (isNaN(fixedValue)) fixedValue = 0;\n    return `${value.toFixed(2)}ms`;\n}\n\nconst useStyles = makeStyles((theme) => ({\n    root: {\n        flexGrow: 1,\n        margin: 'auto',\n        maxWidth: '600px'\n    },\n    paper: {\n        padding: theme.spacing(1),\n        fontSize: '12px',\n        textAlign: 'center',\n        color: theme.palette.text.secondary,\n    },\n    control: {\n        padding: theme.spacing(2),\n    },\n}));\n\nconst Chart = (props) => {\n    const [formattedData, setFormattedData] = useState([]);\n    const [derivedFields, setDerivedFields] = useState([]);\n    const [cachedNumHeaderRows, setCachedNumHeaderRows] = useState(0);\n    const [cachedFormattedDataSize, setCachedFormattedDataSize] = useState(0);\n\n    const classes = useStyles();\n\n    useEffect(() => {\n        const interval = setInterval(() => {\n            if (formattedData.length !== cachedFormattedDataSize) {\n                setCachedFormattedDataSize(formattedData.length);\n                computeDerivedFields();\n            }\n        }, COMPUTE_DERIVED_FIELDS_INTERVAL);\n        return () => clearInterval(interval);\n    });\n\n    const computeDerivedFields = () => {\n        // Remove header row of formatted data\n        var data = formattedData.filter(obj => typeof obj[0] === 'string' && obj[1] !== 'Meta');\n        console.log(formattedData);\n\n        // Find unqiue behaviors in existing data\n        const uniqueBehaviors = [];\n        data.forEach(event => {\n            if (uniqueBehaviors.indexOf(event[0]) === -1) {\n                uniqueBehaviors.push(event[0])\n            }\n        });\n\n        var tempDerivedFields = [];\n        const keybindMap = KeybindMap.Keybinds;\n\n        // Derive fields for each unique behavior\n        uniqueBehaviors.forEach(behavior => {\n            var occurences = 0, totalDuration = 0;\n            var matchingEvents = data.filter(event => event[0] === behavior);\n            var order = keybindMap.filter(keybind => keybind.behavior === behavior).order;\n\n            console.log(\"finding derived fields for \" + behavior + \" found \" + matchingEvents.length + \" events\");\n\n            occurences = matchingEvents.length;\n\n            matchingEvents.forEach(event => {\n                totalDuration += (event[3] - event[2]);\n            });\n\n            var avgDuration = (totalDuration / occurences);\n            if (occurences === 0) avgDuration = 0;\n\n            var derivedField = {\n                order: order,\n                behavior: behavior,\n                occurences: occurences,\n                totalDuration: totalDuration,\n                avgDuration: avgDuration\n            }\n\n            tempDerivedFields.push(derivedField);\n        });\n\n        // Sort derived fields by order property\n        tempDerivedFields.sort((a, b) => {\n            if (a.order !== undefined && b.order !== undefined) {\n                return (a.order > b.order) ? 1 : -1;\n            } else {\n                var textA = a.behavior.toUpperCase();\n                var textB = b.behavior.toUpperCase();\n                return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;\n            }\n        });\n\n        setDerivedFields((derivedFields) => {\n            derivedFields = tempDerivedFields;\n            console.log(derivedFields);\n\n            return derivedFields;\n        });\n        props.state.derivedFields = derivedFields;\n    };\n\n    const formatEvent = (latestEvent) => {\n        // for display purposes, set a minimum value for durations\n        if ((latestEvent.end - latestEvent.start) < MIN_EVENT_DURATION) latestEvent.end += MIN_EVENT_DURATION;\n\n        // Seach existing records for similar start, end, duration times and adjust by the MIN_EVENT_DURATION\n        // This is to account for key presses that happen faster than the update cycle of React\n        props.state.data.events.forEach(obj => {\n            if (obj.id !== latestEvent.id && obj.behavior === latestEvent.behavior) {\n                if (obj.start === latestEvent.start) {\n                    console.warn(\"Adjusted event start time due to existing similar events: \" + latestEvent.id);\n                    latestEvent.start += (MIN_EVENT_DURATION + (0.1 * MIN_EVENT_DURATION));\n                }\n\n                if (obj.behavior === latestEvent.behavior && obj.end === latestEvent.start) {\n                    console.warn(\"Adjusted event start time due to existing similar events: \" + latestEvent.id);\n                    latestEvent.start += (0.1 * MIN_EVENT_DURATION);\n                }\n\n                if (obj.end === latestEvent.end) {\n                    console.warn(\"Adjusted event end time due to existing similar events: \" + latestEvent.id);\n                    latestEvent.end += (MIN_EVENT_DURATION + (0.1 * MIN_EVENT_DURATION));\n                }\n            }\n        });\n\n        return [\n            latestEvent.behavior,\n            \"Event: #\" + latestEvent.id,\n            convertToMilliseconds(latestEvent.start),\n            convertToMilliseconds(latestEvent.end)\n        ];\n    };\n\n    useEffect(() => {\n        var isDataLoaded = (props.state.dataFileName !== '');\n        var isFormattedDataEmpty = (formattedData.length === 0);\n        var areEventsEmpty = (props.state.data.events && props.state.data.events.length === 0);\n\n        // Video has been cleared, reset the chart\n        if (!isDataLoaded && formattedData.length !== 0) {\n            setFormattedData([]);\n            setDerivedFields([]);\n        }\n\n        if (isDataLoaded && isFormattedDataEmpty) {\n            var headerRows = [\n                [\n                    { type: 'string', id: 'Behavior' },\n                    { type: 'string', id: 'Event' },\n                    { type: 'number', id: 'Start' },\n                    { type: 'number', id: 'End' },\n                ],\n                [\n                    \"Behavior\", \"Meta\", 0, convertToMilliseconds(props.state.data.metadata.duration)\n                ]\n            ];\n\n            if (props.state.isVideo && areEventsEmpty) {\n                // Adding empty Behavior records to force a consistent order\n                props.state.keybinds.forEach(obj => {\n                    headerRows.push([obj.behavior, \"Meta\", 0, 0]);\n                });\n            } else if (!areEventsEmpty) {\n                // Likely coming from a data upload - find unique behaviors and sort them alphabetically if order property does not exist\n                // Find unqiue behaviors in existing data\n                const uniqueBehaviors = [];\n                props.state.data.events.forEach(event => {\n                    if (uniqueBehaviors.indexOf(event.behavior) === -1) {\n                        uniqueBehaviors.push(event.behavior)\n                    }\n                });\n                console.log(JSON.stringify(uniqueBehaviors));\n                uniqueBehaviors.sort((a, b) => {\n                    var textA = a.toUpperCase();\n                    var textB = b.toUpperCase();\n                    return (textA < textB) ? -1 : (textA > textB) ? 1 : 0;\n                });\n                uniqueBehaviors.forEach(behavior => {\n                    headerRows.push([behavior, \"Meta\", 0, 0]);\n                });\n            }\n\n            setCachedNumHeaderRows(headerRows.length)\n            setFormattedData(headerRows);\n        }\n\n        // Check if events exist to avoid running code when idle\n        var eventsExist = (props.state.data.events && props.state.data.events.length > 0);\n        // Check if a new event exists -- length of data.events plus header rows\n        var newEventExists = ((props.state.data.events.length + cachedNumHeaderRows) > formattedData.length);\n\n        // Add new event and compute derived fields when new record is persisted\n        if (eventsExist && newEventExists) {\n            var eventsDiff = ((props.state.data.events.length + cachedNumHeaderRows) - formattedData.length);\n            var formattedEvents = [], unformattedEvent, formattedEvent;\n\n            while (eventsDiff > 0) {\n                unformattedEvent = props.state.data.events[props.state.data.events.length - eventsDiff];\n                formattedEvent = formatEvent(unformattedEvent);\n                formattedEvents.push(formattedEvent);\n                eventsDiff--;\n            }\n\n            setFormattedData(formattedData => (formattedData.concat(formattedEvents)));\n        }\n    });\n\n    return (\n        <div className=\"Row\">\n            {derivedFields.length > 0 && (\n                derivedFields.map((derivedField) =>\n                    <Grid container className={classes.root} spacing={2} key={derivedField.behavior}>\n                        <Grid item xs={3}>\n                            <Paper className={classes.paper}>\n                                <Typography variant=\"caption\" display=\"inline\" gutterBottom>    Behavior:   </Typography>\n                                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\" gutterBottom >{derivedField.behavior}</Typography>\n                            </Paper>\n                        </Grid>\n                        <Grid item xs={3}>\n                            <Paper className={classes.paper}>\n                                <Typography variant=\"caption\" display=\"inline\" gutterBottom>    Occurences: </Typography>\n                                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\" gutterBottom >{derivedField.occurences}</Typography>\n                            </Paper>\n                        </Grid>\n                        <Grid item xs={3}>\n                            <Paper className={classes.paper}>\n                                <Typography variant=\"caption\" display=\"inline\" gutterBottom>    Avg Duration:   </Typography>\n                                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\" gutterBottom >{formatTime(derivedField.avgDuration)}</Typography>\n                            </Paper>\n                        </Grid>\n                        <Grid item xs={3}>\n                            <Paper className={classes.paper}>\n                                <Typography variant=\"caption\" display=\"inline\" gutterBottom>    Total Duration:    </Typography>\n                                <Typography variant=\"subtitle2\" display=\"block\" align=\"center\" gutterBottom >{formatTime(derivedField.totalDuration)}</Typography>\n                            </Paper>\n                        </Grid>\n                    </Grid>\n                )\n            )}\n            <div id=\"chart-container\" className=\"GoogleChart\">\n                {formattedData.length > 1 && (\n                    <GoogleChart\n                        width={'840px'}\n                        height={'400px'}\n                        chartType=\"Timeline\"\n                        data={formattedData}\n                        options={{\n                            timeline: {\n                                colorByRowLabel: true,\n                                margin: 'auto',\n                                showBarLabels: false,\n                            },\n                            colors: ['transparent', '#469FAE', '#3ECDB6', '#C09BD8', '#F67E5C', '#CA1252', '#DD5B5C', '#D9959A', '#938D99', '#5E614A'],\n                        }}\n                        rootProps={{ 'data-testid': '6' }}\n                    />\n                )}\n            </div>\n        </div>\n    );\n}\n\nexport default Chart;",["33","34"],"/Users/zcranfill/Test/video-keypress/src/hooks/keybindMap.js",[],{"ruleId":"35","severity":1,"message":"36","line":7,"column":8,"nodeType":"37","messageId":"38","endLine":7,"endColumn":16},{"ruleId":"35","severity":1,"message":"39","line":18,"column":8,"nodeType":"37","messageId":"38","endLine":18,"endColumn":18},{"ruleId":"35","severity":1,"message":"40","line":21,"column":8,"nodeType":"37","messageId":"38","endLine":21,"endColumn":17},{"ruleId":"35","severity":1,"message":"41","line":23,"column":8,"nodeType":"37","messageId":"38","endLine":23,"endColumn":21},{"ruleId":"35","severity":1,"message":"42","line":25,"column":8,"nodeType":"37","messageId":"38","endLine":25,"endColumn":20},{"ruleId":"35","severity":1,"message":"43","line":30,"column":8,"nodeType":"37","messageId":"38","endLine":30,"endColumn":20},{"ruleId":"35","severity":1,"message":"44","line":36,"column":8,"nodeType":"37","messageId":"38","endLine":36,"endColumn":19},{"ruleId":"35","severity":1,"message":"45","line":40,"column":8,"nodeType":"37","messageId":"38","endLine":40,"endColumn":14},{"ruleId":"35","severity":1,"message":"46","line":325,"column":11,"nodeType":"37","messageId":"38","endLine":325,"endColumn":26},{"ruleId":"35","severity":1,"message":"47","line":386,"column":12,"nodeType":"37","messageId":"38","endLine":386,"endColumn":26},{"ruleId":"35","severity":1,"message":"48","line":389,"column":11,"nodeType":"37","messageId":"38","endLine":389,"endColumn":33},{"ruleId":"35","severity":1,"message":"49","line":393,"column":11,"nodeType":"37","messageId":"38","endLine":393,"endColumn":33},{"ruleId":"50","severity":1,"message":"51","line":155,"column":5,"nodeType":"37","endLine":155,"endColumn":14,"suggestions":"52"},{"ruleId":"53","replacedBy":"54"},{"ruleId":"55","replacedBy":"56"},"no-unused-vars","'MenuItem' is defined but never used.","Identifier","unusedVar","'FolderIcon' is defined but never used.","'BlockIcon' is defined but never used.","'ListSubheader' is defined but never used.","'ListItemIcon' is defined but never used.","'KeyboardIcon' is defined but never used.","'ButtonGroup' is defined but never used.","'Button' is defined but never used.","'getPlaybackRate' is assigned a value but never used.","'anchorKeybinds' is assigned a value but never used.","'handleKeybindMenuClick' is assigned a value but never used.","'handleKeybindMenuClose' is assigned a value but never used.","react-hooks/exhaustive-deps","React Hook useEffect contains a call to 'setFormattedData'. Without a list of dependencies, this can lead to an infinite chain of updates. To fix this, pass [props.state.dataFileName, props.state.data.events, props.state.data.metadata.duration, props.state.isVideo, props.state.keybinds, formattedData.length, cachedNumHeaderRows, formatEvent] as a second argument to the useEffect Hook.",["57"],"no-native-reassign",["58"],"no-negated-in-lhs",["59"],{"desc":"60","fix":"61"},"no-global-assign","no-unsafe-negation","Add dependencies array: [props.state.dataFileName, props.state.data.events, props.state.data.metadata.duration, props.state.isVideo, props.state.keybinds, formattedData.length, cachedNumHeaderRows, formatEvent]",{"range":"62","text":"63"},[8971,8971],", [props.state.dataFileName, props.state.data.events, props.state.data.metadata.duration, props.state.isVideo, props.state.keybinds, formattedData.length, cachedNumHeaderRows, formatEvent]"]